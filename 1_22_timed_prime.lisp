; efficiency: (theta (sqrt n))
(define (prime? n) (= n (smallest-divisor n)))
(define (smallest-divisor n)
    (define (divide? n divisor) (= (remainder n divisor) 0))
    (define (next divisor)
        (if (= divisor 2)
            3
            (+ divisor 1)))
    (define (check-divisor n divisor)
        (cond ((> (square divisor) n) n)
            ((divide? n divisor) divisor)
            (else (check-divisor n (next divisor)))
            ))
    (check-divisor n 2)
    )

; efficiency: (theta (log n))
(define (even? n) (= (remainder n 2) 0))
(define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
            (remainder (square (expmod base (/ exp 2) m))
                       m))
          (else (remainder (* base (expmod base (- exp 1) m))
                            m))
        )
    )
(define (fermat-test n)
    (define (try-it a) (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
    (cond ((= times 0) #t)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else #f)
        )
    )

(define (timed-prime n)
    (define (start-timed-prime n start-time found)
        (define (handle-prime)
            (report-elapsed (- (real-time-clock) start-time))
            (if (< found 2)
                (start-timed-prime (+ n 1) (real-time-clock) (+ found 1))))
        (define (handle-just)
            (start-timed-prime (+ n 1) start-time found))
        (newline)
        (display n)
        (if (fast-prime? n 3)
            (handle-prime)
            (handle-just)
            )
        )
    (define (report-elapsed elapsed)
        (display " *** ")
        (display elapsed)
        ; (display (real-time-clock))
        )
    (display (real-time-clock))
    (start-timed-prime n (real-time-clock) 0)
    )
(timed-prime 560)
